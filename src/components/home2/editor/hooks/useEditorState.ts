import { useEffect, useRef, useState, useCallback } from 'react';
import { useAtom, useSetAtom } from 'jotai';
import { debounce } from 'lodash';
import { isModifiedState, isTitleLoadingState, openSnackbarState } from '@/lib/jotai';
import { content } from '@/types';
import { editorViewLogger } from '@/debug/editor';
import { BlockNoteEditor } from '@/components/common/BlockNoteEditor';
import {
    convertBlockNoteToHTML,
    initializeBlockNoteFromHTML,
} from '@/components/common/BlockNoteEditor';
import { useAutoSave } from './useAutoSave';
import { fetchTitling } from '@/functions/ai';

/**
 * 에디터 상태 관리를 담당하는 훅
 * useEditorOperations를 단순화하고 개선
 */
export function useEditorState(
    content: content | null,
    mode: 'create' | 'update' | null,
    editor: BlockNoteEditor | null,
    onSubmit: (id: string, title: string, body: string, is_public: boolean) => void
) {
    const [title, setTitle] = useState('');
    const [body, setBody] = useState('');
    const [isModified, setIsModified] = useAtom(isModifiedState);
    const [bodyLength, setBodyLength] = useState(0);
    const [isInitialized, setIsInitialized] = useState(false);
    const isInitializingRef = useRef(false);

    // 에디터 초기화 실패에 대한 오류 상태
    const [editorHtmlParseError, setEditorHtmlParseError] = useState<Error | null>(null);
    const [fallbackHtml, setFallbackHtml] = useState<string | null>(null);

    // 제목 자동 생성 관련 상태
    const [hasAutoGeneratedTitle, setHasAutoGeneratedTitle] = useState(false);
    const [isTitleLoading, setIsTitleLoading] = useAtom(isTitleLoadingState);
    const [lastTitleGenerationAttempt, setLastTitleGenerationAttempt] = useState(0);
    const titleGeneratedForPageRef = useRef<string | null>(null);
    const openSnackbar = useSetAtom(openSnackbarState);

    editorViewLogger('useEditorState rendering');

    // 가벼운 텍스트 길이 계산 함수 (HTML 변환 없이)
    const calculatePlainTextLength = useCallback((ed: BlockNoteEditor): number => {
        try {
            const blocks = ed.document;
            if (!blocks || !Array.isArray(blocks)) {
                return 0;
            }

            const plainText = blocks
                .map((block) => {
                    if (block && block.content && Array.isArray(block.content)) {
                        return block.content
                            .filter(
                                (content) => content && content.type === 'text' && 'text' in content
                            )
                            .map((content) => (content as any).text)
                            .join('');
                    }
                    return '';
                })
                .join('\n')
                .trim();

            return plainText.length;
        } catch (error) {
            editorViewLogger('텍스트 길이 계산 오류:', error);
            return 0;
        }
    }, []);

    // submit 핸들러
    const submitHandler = useCallback(async () => {
        if (mode === null || !content?.id || !editor) return;

        setIsModified(false);
        editorViewLogger('submitHandler 시작 - isModified false로 설정됨');

        const htmlBody = await convertBlockNoteToHTML(editor);

        // HTML 엔티티를 디코딩하기 위해 DOMParser 사용
        const parser = new DOMParser();
        const doc = parser.parseFromString(htmlBody, 'text/html');
        const plainText = (doc.body.textContent || '').trim();

        // 빈 페이지 검증: 제목과 본문이 모두 비어있으면 저장하지 않음
        const isEmpty = !title.trim() && !plainText;
        if (isEmpty) {
            editorViewLogger('빈 페이지이므로 저장하지 않음', { title, body: htmlBody, plainText });
            return;
        }

        // 제목 자동 생성 로직
        let finalTitle = title.trim();

        if (!finalTitle && plainText.length >= 100) {
            // AI 제목 생성 조건 체크
            const now = Date.now();
            const cooldownPeriod = 30000; // 30초
            const isInCooldown =
                lastTitleGenerationAttempt > 0 && now - lastTitleGenerationAttempt < cooldownPeriod;

            const shouldGenerateTitle =
                !hasAutoGeneratedTitle &&
                !isTitleLoading &&
                !isInCooldown &&
                titleGeneratedForPageRef.current !== content.id;

            if (shouldGenerateTitle) {
                try {
                    setIsTitleLoading(true);
                    setLastTitleGenerationAttempt(now);

                    editorViewLogger('AI 제목 생성 시작', { pageId: content.id });

                    const {
                        data: { createdTitle },
                    } = await fetchTitling(content.id, htmlBody);

                    if (createdTitle) {
                        finalTitle = createdTitle;
                        setTitle(createdTitle);
                        setHasAutoGeneratedTitle(true);
                        titleGeneratedForPageRef.current = content.id;
                        editorViewLogger('AI 제목 생성 완료', { createdTitle });
                    } else {
                        finalTitle = plainText.substring(0, 20);
                        editorViewLogger('AI 제목 생성 실패 - fallback 사용');
                    }
                } catch (error: any) {
                    editorViewLogger('제목 생성 에러', error);

                    // 사용량 초과 에러 처리
                    if (error.isQuotaExceeded) {
                        openSnackbar({
                            message: error.message || '월간 AI 사용량이 초과되었습니다.',
                        });
                        editorViewLogger('사용량 한도 초과로 제목 생성 실패');
                    }

                    // 에러 발생 시 fallback
                    finalTitle = plainText.substring(0, 20);
                } finally {
                    setIsTitleLoading(false);
                }
            } else {
                // 조건 미충족 시 fallback
                finalTitle = plainText.substring(0, 20);
                editorViewLogger('AI 제목 생성 조건 미충족 - fallback 사용', {
                    isInCooldown,
                    hasAutoGeneratedTitle,
                    isTitleLoading,
                    alreadyGenerated: titleGeneratedForPageRef.current === content.id,
                });
            }
        } else if (!finalTitle) {
            // 100글자 미만이면 기본 fallback
            finalTitle = plainText.substring(0, 20) || '제목 없음';
        }

        const isPublic = content?.is_public ?? false;

        onSubmit(content.id, finalTitle, htmlBody, isPublic);

        // 제출 후 명시적으로 다시 한번 isModified 설정
        setTimeout(() => {
            setIsModified(false);
            editorViewLogger('submitHandler 완료 후 - isModified false로 설정됨');
        }, 0);

        editorViewLogger('onSubmit 완료', {
            id: content.id,
            title: finalTitle,
            body: htmlBody,
            is_public: isPublic,
        });
    }, [editor, onSubmit, setIsModified, title, mode, content]);

    // 자동저장 훅 사용
    const { lastAutoSaveTime, isAutoSaving, triggerAutoSave } = useAutoSave({
        isModified,
        submitHandler,
        autoSaveInterval: 3000,
    });

    // triggerAutoSave를 ref로 관리하여 의존성 배열 안정화
    const triggerAutoSaveRef = useRef(triggerAutoSave);
    useEffect(() => {
        triggerAutoSaveRef.current = triggerAutoSave;
    }, [triggerAutoSave]);

    // 통합된 디바운싱 에디터 업데이트 핸들러
    const debouncedEditorUpdateHandler = useCallback(
        debounce(
            async () => {
                if (!editor) {
                    editorViewLogger('통합 에디터 업데이트 핸들러 - editor가 null');
                    return;
                }
                try {
                    editorViewLogger('통합 에디터 업데이트 핸들러 시작');
                    const htmlBody = await convertBlockNoteToHTML(editor);
                    setBody(htmlBody);
                    editorViewLogger('body 상태 업데이트 완료');
                } catch (error) {
                    editorViewLogger('통합 에디터 업데이트 핸들러 오류:', error);
                }
            },
            1000,
            { trailing: true, leading: false }
        ),
        [editor]
    );

    // 이전 mode를 추적하여 create → update 전환 시 재초기화 방지
    const prevModeRef = useRef<'create' | 'update' | null>(null);

    // Initialize editor state based on content
    useEffect(() => {
        if (!editor) {
            setIsInitialized(false);
            return;
        }
        // mode가 null이면 아직 준비가 안된 상태임.
        if (mode === null) {
            editorViewLogger('수정 모드 데이터 로딩 중 - 초기화 대기');
            setIsInitialized(false);
            return;
        }

        // 신규 페이지 저장 후 mode가 create → update로 변경된 경우 재초기화 방지
        // 이미 편집 중인 내용을 유지해야 함
        if (prevModeRef.current === 'create' && mode === 'update') {
            editorViewLogger('create → update 전환 - 재초기화 건너뜀 (편집 중인 내용 유지)');
            prevModeRef.current = mode;
            return;
        }

        prevModeRef.current = mode;

        async function initializeEditor(initialBody: string | null | undefined) {
            if (!editor) return;

            isInitializingRef.current = true;
            setIsInitialized(false);
            setEditorHtmlParseError(null); // Clear previous errors

            try {
                await initializeBlockNoteFromHTML(editor, initialBody);

                // 에디터 document 검증
                const hasInvalidBlocks = editor.document.some((block) => !block.id);
                if (hasInvalidBlocks) {
                    editorViewLogger('경고: id가 없는 블록 발견', {
                        blocks: editor.document.map((b) => ({ id: b.id, type: b.type })),
                    });
                    // id가 없는 블록이 있으면 에러 발생
                    isInitializingRef.current = false;
                    throw new Error('Invalid blocks detected - blocks without id');
                }

                editorViewLogger('Editor initialized/updated with new content', {
                    blockCount: editor.document.length,
                    allBlocksHaveIds: editor.document.every((b) => b.id),
                    initialBody,
                });

                // 초기화 완료
                // 초기화 과정에서 발생하는 onChange 이벤트를 무시하기 위해 지연 실행
                // 50ms -> 500ms로 증가하여 안정성 확보
                isInitializingRef.current = false;
                setIsInitialized(true);
                // 강제로 수정 상태 초기화 (초기화 과정에서 true가 되었을 수 있음)
                setIsModified(false);
                editorViewLogger('초기화 완료 - 플래그 해제 및 isModified false 설정');
            } catch (error) {
                // Capture error and fallback HTML
                isInitializingRef.current = false;
                setEditorHtmlParseError(error as Error);
                setFallbackHtml((error as any).fallbackHtml || initialBody || null);
                setIsInitialized(true); // Mark as "initialized" so we can show fallback
                editorViewLogger('에디터 초기화 실패 - fallback HTML 사용', { error });
            }
        }

        async function runInit() {
            if (mode === 'create') {
                // create mode
                try {
                    setTitle('');
                    setBody('');
                    await initializeEditor(null);
                    setIsModified(false);
                    editorViewLogger('createInit - 제목과 본문 상태 및 에디터 초기화됨');
                } catch (error) {
                    editorViewLogger('createInit 오류:', error);
                    setIsInitialized(false);
                }
            } else if (mode === 'update') {
                // update mode
                try {
                    const newTitle = content?.title || '';
                    const newBody = content?.body || '';
                    setTitle(newTitle);
                    setBody(newBody);
                    await initializeEditor(newBody);
                    setIsModified(false);
                    editorViewLogger('updateInit - 제목과 본문 상태 및 에디터 업데이트됨');
                } catch (error) {
                    editorViewLogger('updateInit 오류:', error);
                    setIsInitialized(false);
                }
            }
        }

        runInit();
    }, [content, mode, editor, setIsModified]);

    // Editor change handler setup
    useEffect(() => {
        if (!editor) return;

        const handleEditorChange = async () => {
            if (isInitializingRef.current) {
                editorViewLogger('초기화 중이므로 onChange 처리 건너뜀');
                return;
            }

            editorViewLogger('onChange 처리됨 - 수정 상태로 변경');
            setIsModified(true);

            // 가벼운 글자수 계산
            const plainTextLength = calculatePlainTextLength(editor);
            setBodyLength(plainTextLength);

            // 자동저장 트리거
            if (triggerAutoSaveRef.current) {
                triggerAutoSaveRef.current();
            }

            // Body 상태 업데이트 (디바운스)
            debouncedEditorUpdateHandler();

            editorViewLogger('editor.onChange 실행 완료');
        };

        editorViewLogger('editor.onChange 이벤트 리스너 등록 시작');
        const unsubscribe = editor.onChange(handleEditorChange);

        return () => {
            editorViewLogger('editor.onChange 이벤트 리스너 제거 시작');
            debouncedEditorUpdateHandler.cancel();

            if (unsubscribe) {
                unsubscribe();
            }
        };
    }, [editor, calculatePlainTextLength, debouncedEditorUpdateHandler, setIsModified]);

    // 제목 수정 시 플래그 초기화
    useEffect(() => {
        if (title && title.trim() !== '') {
            if (hasAutoGeneratedTitle) {
                setHasAutoGeneratedTitle(false);
                editorViewLogger('제목 수정됨 - 자동 생성 플래그 초기화');
            }
        }
    }, [title, hasAutoGeneratedTitle]);

    // 페이지 변경 시 플래그 초기화
    useEffect(() => {
        setHasAutoGeneratedTitle(false);
        setLastTitleGenerationAttempt(0);
        titleGeneratedForPageRef.current = null;
        prevModeRef.current = null; // 페이지 전환 시 mode 추적 초기화
        editorViewLogger('페이지 변경 - 제목 자동 생성 플래그 초기화', { pageId: content?.id });
    }, [content?.id]);

    return {
        title,
        setTitle,
        body,
        submitHandler,
        isModified,
        setIsModified,
        bodyLength,
        isAutoSaving,
        lastAutoSaveTime,
        triggerAutoSave,
        isInitialized,
        editorHtmlParseError,
        fallbackHtml,
    };
}
